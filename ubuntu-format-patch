#!/usr/bin/env python3
#
# Format patches for submission to an Ubuntu kernel mailing list
#

import gzip
import json
import os
import shutil
import sys
import textwrap
from datetime import datetime
from email.utils import format_datetime, make_msgid
from subprocess import check_call

import click
import git
import requests
from debian.changelog import Changelog
from launchpadlib.launchpad import Launchpad

CACHEDIR = os.path.join(os.path.expanduser("~"), ".cache", "ubuntu-format-patch")
COLS = int(os.popen("tput cols", "r").read().strip())


def print_banner(text, invert=True, color=1):
    text = text + " " * COLS
    x = 48 if invert else 38
    print(f"\033[{x};5;{color}m{text[:COLS]}\033[0m")


def print_patch(patchfile):
    """Pretty-print a patch file"""
    with open(patchfile, encoding="utf-8") as fh:
        in_diff = False
        for line in fh:
            line = line.rstrip("\n")
            if line.startswith("diff --git a/"):
                in_diff = True

            cc = 0
            if in_diff:
                if ((line.startswith("diff --git ") or line.startswith("index ") or
                     line.startswith("--- a") or line.startswith("+++ b"))):
                    cc = 1
                elif line.startswith("@@ "):
                    cc = 36
                elif line.startswith("+"):
                    cc = 32
                elif line.startswith("-"):
                    cc = 31

            color = f"\033[{cc}m" if cc else ""
            nc = "\033[0m" if cc else ""
            print(f"{color}{line}{nc}")


def get_debian_dir():
    if os.path.exists("debian/debian.env"):
        with open("debian/debian.env", encoding="utf-8") as fh:
            return fh.readline().split("=")[1].strip()
    return "debian"


def get_handle(debian_dir):
    with open(os.path.join(debian_dir, "changelog"), encoding="utf-8") as fh:
        ch = Changelog(fh, max_blocks=1)
    return ch.distributions, ch.package


def get_series_data(ks, series):
    for _, series_data in ks.items():
        if series_data.get("codename") == series:
            return series_data
    print(f"Error: Series '{series}' not found in kernel-series", file=sys.stderr)
    sys.exit(1)


def get_source_data(series_data, source):
    for _, source_data in series_data["sources"].items():
        for package, _ in source_data["packages"].items():
            if package == source:
                return source_data
    print(f"Error: Source '{source}' not found in kernel-series", file=sys.stderr)
    sys.exit(1)


class KernelPackage:
    def __init__(self, ks, handle):
        self.series, self.source = handle

        series_data = get_series_data(ks, self.series)
        source_data = get_source_data(series_data, self.source)

        series_devel = series_data.get("development", False)
        series_supported = series_data.get("supported", False)
        series_esm = series_data.get("esm", False)

        self.is_devel = source_data.get("development", series_devel)
        self.is_supported = source_data.get("supported", True) if series_supported else False
        self.is_esm = series_esm

    def subject_tag(self):
        """Return the patch subject tag for this kernel package"""
        s = self.series[0].upper()
        p = self.source.removeprefix("linux").removeprefix("-")
        if p:
            return f"{s}:{p}"
        return s


class Submission:
    def __init__(self, sid=None):
        self.sid = sid or "default"
        self.dir = os.path.join(CACHEDIR, self.sid)
        self.ks_cached = None
        self.info = {}
        self.load()

    def load(self):
        """Load info from file"""
        filename = os.path.join(self.dir, "info.json")
        if os.path.exists(filename):
            with open(filename, encoding="utf-8") as fh:
                self.info = json.load(fh)

    def save(self):
        """Save info to file"""
        filename = os.path.join(self.dir, "info.json")
        with open(filename, "w", encoding="utf-8") as fh:
            fh.write(json.dumps(self.info))

    def set(self, **kwargs):
        """Set info data"""
        for key, val in kwargs.items():
            if key == "patch_sets":
                if key not in self.info:
                    self.info[key] = []
                if val and val not in self.info[key]:
                    self.info[key].append(val)
            else:
                self.info[key] = val

    def init(self, subject=None, bug=None):
        """Initialize environment"""
        if os.path.exists(self.dir):
            shutil.rmtree(self.dir)
        os.makedirs(self.dir)

        # Pull bug title and description from Launchpad
        description = ""
        if bug:
            print(f"-- Query Launchpad (LP: #{bug})")
            lp = Launchpad.login_with("ubuntu-format-patch", "production", version="devel")
            lp_bug = lp.bugs[bug]
            description = lp_bug.description
            if not subject:
                subject = f"{lp_bug.title} (LP: #{bug})"

        # Save initial info data
        self.info = {}
        self.set(subject=subject, bug=bug, description=description, message_id=make_msgid(),
                 patch_sets=None)
        self.save()

        # Cache kernel-series.json
        print("-- Cache kernel-series.json.gz")
        ks = os.path.join(self.dir, "ks.gz")
        r = requests.get("https://kernel.ubuntu.com/info/kernel-series.json.gz", timeout=5)
        with open(ks, "wb") as fh:
            fh.write(r.content)

    def ks(self):
        """Return cached kernel-series data"""
        if not self.ks_cached:
            with gzip.open(os.path.join(self.dir, "ks.gz")) as fh:
                self.ks_cached = json.load(fh)
        return self.ks_cached

    def show(self):
        """Pretty-print our data"""
        print(f"sid: {self.sid}")
        print(f"dir: {self.dir}")
        print("info:")
        print(json.dumps(self.info, indent=4))
        print("description:")
        with open(self.description_file(), encoding="utf-8") as fh:
            for line in fh:
                print(" " + line, end="")
        print("patches:")
        for p in self.patches():
            print(" " + p)

    def patches(self):
        """Return the list of patch files"""
        p = [os.path.join(self.dir, "0000-cover-letter.patch")]
        for item in sorted(self.patch_sets(), reverse=True):
            d = os.path.join(self.dir, item)
            for f in sorted(os.listdir(d)):
                if not f.endswith(".patch"):
                    continue
                p.append(os.path.join(d, f))
        return p

    def patches_dir(self, name, force=False):
        """Create the patches directory and return its pathname"""
        self.set(patch_sets=name)
        dirname = os.path.join(self.dir, name)
        if os.path.exists(dirname):
            if not force:
                print("Error: Patchset exists already. Use --force to overwrite it.",
                      file=sys.stderr)
                sys.exit(1)
            shutil.rmtree(dirname)
        return dirname

    def bug(self):
        return self.info["bug"]

    def description(self):
        return self.info["description"]

    def description_file(self):
        """Create the per-patchset description file and return its pathname"""
        filename = os.path.join(self.dir, "description")
        if not os.path.exists(filename):
            with open(filename, "w", encoding="utf-8") as fh:
                fh.write(f"{self.subject()}\n\n")
                fh.write(f"BugLink: https://bugs.launchpad.net/bugs/{self.bug()}\n")
        return filename

    def message_id(self):
        return self.info["message_id"]

    def patch_sets(self):
        return self.info["patch_sets"]

    def sru(self):
        return self.info["sru"]

    def subject(self):
        return self.info["subject"]


@click.group()
def cli():
    pass


@cli.command()
@click.option("--sid", help="Submission ID.")
@click.option("--subject", help="Email subject for patch submission.")
@click.option("--bug", type=int, help="Launchpad bug that this submission fixes.")
def init(sid, subject, bug):
    """Initialize a new patchset submission."""
    sub = Submission(sid=sid)
    sub.init(subject=subject, bug=bug)
    print(f"-- Initialized: {sub.dir}")
    print(f"-- Submission subject: {sub.subject()}")


@cli.command()
@click.option("--sid", help="Submission ID.")
def info(sid):
    """Print patchset submission info."""
    sub = Submission(sid=sid)
    sub.show()


@cli.command()
@click.option("--force", is_flag=True, help="Overwrite an existing patchset.")
@click.option("--sid", help="Submission ID.")
@click.argument("revision-range", nargs=-1, type=click.UNPROCESSED)
def format_patch(force, sid, revision_range):
    """Format patches."""
    sub = Submission(sid=sid)
    repo = git.Repo()

    debian_dir = get_debian_dir()
    handle = get_handle(debian_dir)
    kp = KernelPackage(sub.ks(), handle)

    ktag = kp.subject_tag()
    print(f"-- Create patchset ({ktag})")

    if kp.is_supported:
        subject_prefix = f"SRU][{ktag}][PATCH"
        sub.set(sru=True)
    else:
        subject_prefix = f"{ktag}][PATCH"

    # Create the patchset
    patches_dir = sub.patches_dir(ktag, force=force)
    opts = [
        f"--output-directory={patches_dir}",
        "--cover-letter",
        "--cover-from-description=subject",
        f"--description-file={sub.description_file()}",
        "--thread=shallow",
        f"--in-reply-to={sub.message_id()}",
        f"--subject-prefix={subject_prefix}",
    ] + list(revision_range)
    repo.git.format_patch(opts)

    sub.save()


@cli.command()
@click.option("--sid", help="Submission ID.")
def format_thread(sid):
    """Format thread."""
    sub = Submission(sid=sid)

    patch_sets = sorted(sub.patch_sets(), reverse=True)
    if not patch_sets:
        print("Errr: No patchsets found.", file=sys.stderr)
        sys.exit(1)

    print("-- Create patch submission")

    # TBD: Move cover letter generation to Submission class

    repo = git.Repo()
    name = repo.config_reader().get_value("user", "name")
    email = repo.config_reader().get_value("user", "email")
    date = format_datetime(datetime.now().astimezone())

    # Construct the subject
    if sub.sru():
        subject = "[SRU]"
    else:
        subject = ""
    subject += "[" + "/".join(patch_sets) + "]"
    subject += "[PATCH 0/" + str(len(patch_sets)) + "]"
    subject += " " + sub.subject()

    # Generate the cover letter
    cover_letter = os.path.join(sub.dir, "0000-cover-letter.patch")
    with open(cover_letter, "w", encoding="utf-8") as fh:
        fh.write(f"From {email} Mon Sep 17 00:00:00 2001\n")
        fh.write(f"Message-ID: {sub.message_id()}\n")
        fh.write(f"From: {name} <{email}>\n")
        fh.write(f"Date: {date}\n")
        fh.write(f"Subject: {subject}\n")
        fh.write("\n")
        fh.write(f"BugLink: https://bugs.launchpad.net/bugs/{sub.bug()}\n\n")
        for line in sub.description().split("\n"):
            fh.write(f"{textwrap.fill(line, width=80)}\n")

    print(subject)
    for p in patch_sets:
        print("  " + p)
    print("--")


@cli.command()
@click.option("--sid", help="Submission ID.")
def show(sid):
    """Show all patches of a submission."""
    sub = Submission(sid=sid)
    for p in sub.patches():
        print()
        print_banner("  " + p.partition(f"/{sub.sid}/")[2].replace("/", " -- "))
        print()
        print_patch(p)


@cli.command()
@click.option("--sid", help="Submission ID.")
@click.option("--dry-run", is_flag=True)
@click.option("--to")
def send_email(sid, dry_run, to):
    """Send all patches to the mailing list."""
    if not to:
        to = "kernel-team@lists.ubuntu.com"

    sub = Submission(sid=sid)
    patches = sub.patches()

    opts = ["--dry-run"] if dry_run else []
    opts += [
        "--suppress-cc=all",
        f"--to={to}",
    ] + patches

    cmd = ["git", "send-email"] + opts
    print(cmd)
    print()

    check_call(cmd)


if __name__ == "__main__":
    cli()
