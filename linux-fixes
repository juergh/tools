#!/usr/bin/env python3

import gzip
import json
import os
import re
import sys

import click
import git

RE_FIXES = re.compile(r"^\s*Fixes:.*\b([0-9a-f]{8,})\b")


def list_fixes(sha, db, level=0):
    """Recursively return all commits that fix the provided commit"""
    db_commit = db.commit(sha)
    if not db_commit:
        return
    yield db_commit, level
    for fixed_by_sha in db_commit.fixed_by:
        yield from list_fixes(fixed_by_sha, db, level=level + 1)


class CommitCache:
    cache = {}

    def lookup(self, sha, repo=None):
        if sha not in self.cache and repo:
            try:
                self.cache[sha] = repo.commit(sha)
            except git.BadName:
                # Invalid SHA
                pass
            except ValueError:
                # fatal: bad object <SHA>
                pass
        return self.cache.get(sha)


CC = CommitCache()


class Commit:
    sha = None
    subject = None
    fixes_tags = []
    fixes = []
    fixed_by = []

    def from_commit(self, commit, fixed_by=None):
        """Load the object data from the provided GitPython commit object"""
        self.sha = commit.hexsha
        self.subject = commit.summary

        if fixed_by:
            self.fixed_by = [fixed_by]
        else:
            for line in commit.message.split("\n"):
                m = RE_FIXES.match(line)
                if m:
                    self.fixes_tags.append(line)
                    fixes_sha = m.group(1)
                    fixes_commit = CC.lookup(fixes_sha, repo=commit.repo)
                    if fixes_commit:
                        self.fixes.append(fixes_commit.hexsha)
        return self

    def from_dict(self, cdict):
        """Load the object data from the provided dict"""
        self.sha = cdict.get("sha", self.sha)
        self.subject = cdict.get("subject", self.subject)
        self.fixes_tags = cdict.get("fixes-tags", self.fixes_tags)
        self.fixes = cdict.get("fixes", self.fixes)
        self.fixed_by = cdict.get("fixed-by", self.fixed_by)
        return self

    def to_dict(self):
        """Return the object data as a dict"""
        return {
            "sha": self.sha,
            "subject": self.subject,
            "fixes-tags": self.fixes_tags,
            "fixes": self.fixes,
            "fixed-by": self.fixed_by,
        }

    def print(self, indent=0, color=None):
        """Pretty print the commit"""
        colors = {
            "red": "\033[31m",
            "green": "\033[32m",
            "yellow": "\033[33m",
        }
        cc = colors.get(color, "")
        nc = "" if cc == "" else "\033[0m"

        sys.stdout.write(f"{' ' * indent}{cc}{self.sha[:12]}{nc} {self.subject}\n")
        sys.stdout.flush()

    def dump(self):
        """Dump the object data to stdout"""
        print(json.dumps(self.to_dict(), indent=4))


class DataBase:
    def __init__(self):
        self.db = {}

    @property
    def head(self):
        return self.db.get("HEAD")

    @head.setter
    def head(self, value):
        self.db["HEAD"] = value

    def load(self, filename):
        """Load the database from file"""
        if os.path.exists(filename):
            with gzip.open(filename, "rt", encoding="utf-8") as fh:
                self.db = json.load(fh)
        else:
            print(f"W: Database file does not exist: {filename}", file=sys.stderr)

    def save(self, filename):
        """Save the database to file"""
        with gzip.open(filename, "wt", encoding="utf-8") as fh:
            json.dump(self.db, fh, ensure_ascii=False)

    def _add_commit(self, commit):
        """Add a single commit to the database"""
        sha = commit.sha
        if sha in self.db:
            cur = self.db[sha]
            new = commit.to_dict()
            for key in ["fixes-tags", "fixes", "fixed-by"]:
                cur[key] = list(set(cur[key] + new[key]))
            self.db[sha] = cur
        else:
            self.db[sha] = commit.to_dict()

    def add_commit(self, commit):
        """Add the provided commits plus any commits it fixes"""
        self._add_commit(commit)
        for sha in commit.fixes:
            fixes_commit = Commit().from_commit(CC.lookup(sha), fixed_by=commit.sha)
            self._add_commit(fixes_commit)

    def commit(self, sha):
        """Return the commit with the provided SHA"""
        if len(sha) != 40:
            for key in self.db.keys():
                if key.startswith(sha):
                    sha = key
                    break
        return Commit().from_dict(self.db.get(sha, {}))

    def dump(self):
        """Dump the database to stdout"""
        print(json.dumps(self.db, indent=4))


@click.group()
@click.argument("fixes-file")
@click.pass_context
def cli(ctx, fixes_file):
    print(f"fixes-file: {fixes_file}")
    ctx.obj = {"fixes_file": fixes_file}


@cli.command()
@click.option("--dry-run/--no-dry-run", help="Don't save any changes.")
@click.argument("repo-dir")
@click.argument("branch", default="main")
@click.pass_context
def add(ctx, dry_run, repo_dir, branch):
    """Find commits with 'Fixes:' tags in the provided git repository and add them to the provided fixes file."""
    fixes_file = ctx.obj["fixes_file"]
    db = DataBase()
    db.load(fixes_file)

    if db.head:
        rev_range = f"{db.head}..{branch}"
        reverse = False
    else:
        rev_range = branch
        reverse = True

    print(f"repo-dir:   {repo_dir}")
    print(f"rev-range:  {rev_range}")

    repo = git.Repo(repo_dir)
    for c in repo.iter_commits(rev_range, reverse=reverse, max_parents=1):
        commit = Commit().from_commit(c)
        commit.print()
        if commit.fixes_tags:
            db.add_commit(commit)

    # Store the current HEAD
    db.head = repo.commit(branch).hexsha

    if dry_run:
        print("(dry-run) Not saving any changes")
        return

    # Save the DB back
    db.save(fixes_file)


@cli.command()
@click.argument("commit-sha", nargs=-1)
@click.pass_context
def dump(ctx, commit_sha):
    """Dump the fixes file to stdout."""
    fixes_file = ctx.obj["fixes_file"]
    db = DataBase()
    db.load(fixes_file)

    if not commit_sha:
        # Dump the whole database
        db.dump()
        return

    for sha in commit_sha:
        # Dump the commits with the provided SHAs
        db.commit(sha).dump()


@cli.command()
@click.option("--indent", type=int, default=0)
@click.argument("commit-sha")
@click.pass_context
def fixes(ctx, indent, commit_sha):
    """List commits that fix the provided commit."""
    fixes_file = ctx.obj["fixes_file"]
    db = DataBase()
    db.load(fixes_file)

    for commit, level in list_fixes(commit_sha, db):
        print(f"{' ' * level * indent}", end="")
        commit.print()


@cli.command(context_settings={"ignore_unknown_options": True})
@click.option("--indent", type=int, default=0)
@click.option("--recursive/--no-recursive", default=True)
@click.argument("args", nargs=-1)
@click.pass_context
def log(ctx, indent, recursive, args):
    """List commits and their fixes in the provided rev range."""
    fixes_file = ctx.obj["fixes_file"]
    if not args:
        args = ["HEAD"]

    if "---" in args:
        idx = args.index("---")
        rev_range = args[:idx]
        paths = args[(idx + 1) :]
    else:
        rev_range = args
        paths = []

    print(f"rev-range: {rev_range}")
    print(f"paths:     {paths}")

    db = DataBase()
    db.load(fixes_file)

    sha_list = []

    repo = git.Repo(".")
    for c in repo.iter_commits(rev_range, paths=paths):
        commit = Commit().from_commit(c)

        sha_list.append(commit.sha)

        # Color-print the current commit
        color = "yellow"
        for sha in commit.fixed_by:
            color = "green"
            if sha not in sha_list:
                color = "red"
                break
        commit.print(color=color)

        for fix_commit in db.fix_commits(commit.sha, recursive=recursive, level=1):
            # Color-print the fix commit
            if fix_commit.sha in sha_list:
                color = "green"
            else:
                color = "red"
            fix_commit.print(indent=indent, color=color)


if __name__ == "__main__":
    sys.argv = ["---" if a == "--" else a for a in sys.argv]
    cli()  # pylint: disable=E1120
