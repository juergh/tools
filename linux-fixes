#!/usr/bin/env python3

import gzip
import json
import os
import re

import click
import git

RE_FIXES = re.compile(r"^\s*Fixes:.*\b([0-9a-f]{8,})\b")


class Commit:
    sha = None
    subject = None
    fixes_tags = []
    fixes = []
    fixed_by = []
    level = 0

    def from_commit(self, commit, fixed_by=None):
        """Load the object data from the provided GitPython commit object"""
        self.sha = commit.hexsha
        self.subject = commit.summary

        if fixed_by:
            self.fixed_by = [fixed_by]
        else:
            for line in commit.message.split("\n"):
                m = RE_FIXES.match(line)
                if m:
                    self.fixes_tags.append(line)
                    try:
                        fixes_sha = m.group(1)
                        fixes_commit = commit.repo.commit(fixes_sha)
                        self.fixes.append(Commit().from_commit(commit, fixed_by=self))
                    except git.BadName:
                        # Invalid SHA
                        pass
                    except ValueError:
                        # fatal: bad object <SHA>
                        pass
        return self

    def from_dict(self, cdict):
        """Load the object data from the provided dict"""
        self.sha = cdict["sha"]
        self.subject = cdict["subject"]
        self.fixes_tags = cdict["fixes-tags"]
        self.fixes = cdict["fixes"]
        self.fixed_by = cdict["fixed-by"]
        return self

    def to_dict(self):
        """Return the object data as a dict"""
        return {
            "sha": self.sha,
            "subject": self.subject,
            "fixes-tags": self.fixes_tags,
            "fixes": [c.sha for c in self.fixes],
            "fixed-by": [(c.sha if c else None) for c in self.fixed_by],
        }

    def does_fix(self, sha):
        """Check if this commit fixes the provided commit"""
        if len(sha) == 40:
            if sha in self.fixes:
                return True
            return False

        for f in self.fixes:
            if f.startswith(sha):
                return True
        return False


class DataBase:
    def __init__(self):
        self.db = {}

    @property
    def head(self):
        return self.db.get("HEAD")

    @head.setter
    def head(self, value):
        self.db["HEAD"] = value

    def load(self, filename):
        if os.path.exists(filename):
            with gzip.open(filename, "rt", encoding="utf-8") as fh:
                self.db = json.load(fh)

    def save(self, filename):
        with gzip.open(filename, "wt", encoding="utf-8") as fh:
            json.dump(self.db, fh, ensure_ascii=False)

    def _add_commit(self, commit):
        sha = commit.sha
        if sha in self.db:
            cur = self.db[sha]
            new = commit.to_dict()
            for key in ["fixes-tags", "fixes", "fixed-by"]:
                cur[key].extend(new[key])
                cur[key] = list(set(cur[key]))
            self.db[sha] = cur
        else:
            self.db[sha] = commit.to_dict()

    def add_commit(self, commit):
        # Add the commit itself plus any fixes commits
        for c in [commit] + commit.fixes:
            self._add_commit(c)

    def dump(self):
        print(json.dumps(self.db, indent=4))

    def fix_commits(self, sha, recursive=False, level=0):
        """Return the list of commits that fix the provided commit"""
        sha_list = []
        fix_list = []
        for key, val in self.db.items():
            if key == "HEAD":
                continue

            commit = Commit().from_dict(val)
            if commit.sha in sha_list or not commit.does_fix(sha):
                continue

            sha_list.append(commit.sha)
            commit.level = level
            fix_list.append(commit)

            if recursive:
                for fix in self.fix_commits(
                    commit.sha, recursive=True, level=level + 1
                ):
                    if fix.sha not in sha_list:
                        fix_list.append(fix)

        return fix_list


@click.group()
def cli():
    pass


@cli.command()
@click.argument("fixes-file")
@click.argument("repo-dir")
@click.argument("branch", default="main")
def add(fixes_file, repo_dir, branch):
    """Find commits with 'Fixes:' tags in the provided git repository and add them to the provided fixes file."""
    db = DataBase()
    db.load(fixes_file)

    if db.head:
        rev_range = f"{db.head}..{branch}"
        reverse = False
    else:
        rev_range = branch
        reverse = True

    print(f"fixes-file: {fixes_file}")
    print(f"repo-dir:   {repo_dir}")
    print(f"rev-range:  {rev_range}")

    repo = git.Repo(repo_dir)
    for c in repo.iter_commits(rev_range, reverse=reverse, max_parents=1):
        commit = Commit().from_commit(c)
        print(f'{commit.sha} ("{commit.subject}")')
        if commit.fixes_tags:
            db.add_commit(commit)

    # Store the current HEAD
    db.head = repo.commit(branch).hexsha

    # Save the DB back
    db.save(fixes_file)


@cli.command()
@click.argument("fixes-file")
def dump(fixes_file):
    """Dump the fixes file to stdout."""
    db = DataBase()
    db.load(fixes_file)
    db.dump()


@cli.command()
@click.option("--indent", type=int, default=0)
@click.option("--recursive/--no-recursive", default=True)
@click.argument("fixes-file")
@click.argument("commit")
def fixes(indent, recursive, fixes_file, commit):
    """List commits that fix the provided commit."""
    db = DataBase()
    db.load(fixes_file)

    for fix_commit in db.fix_commits(commit, recursive=recursive):
        print(
            f"{' '*indent*fix_commit.level}{fix_commit.sha[:12]} {fix_commit.subject}"
        )


if __name__ == "__main__":
    cli()
